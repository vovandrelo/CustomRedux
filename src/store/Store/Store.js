// Создание единого источника истинности - некого общего хранилища состояний:
class Store {
  // Реализация класса Store создана по аналогии с объектами Ref, где в качестве current
  // выступает state, благодаря чему изменение данных внутри Store (а точнее внутри state)
  // не повлекут изменение ссылки экземпляра класса.
  state; 

  // Для того, чтобы установить зависимость между изменяемыми данными в глобальном состоянии и
  // нуждающимися в этих данных компонентах, используется поведенческий паттерн проектирования
  // Observer, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать
  // на события, происходящие в других объектах. То есть изменение глобального состояние должно
  // повлечь перерендер только необходимых компонентов, а не всего приложения.

  // Создаём объект, в котором будут храниться данные о компонентах-подписчиках глобального состояния.
  // Структура объекта будет иметь вид: "key": callback, где:
  // - key     : уникальный идентификатор компонента-подписчика.
  // - callback: действие, при совершении которого глобальным источником истинности, компонент-подписчик
  //             поймёт, что глобальное состояние изменилось.
  subscribers = {};

  // Функция, позволяющая разбивать ГС на модули и выполнять их изменение:
  rootReducer;

  // Выполнение конструктора:
  constructor(rootReducer) {
    this.rootReducer = rootReducer;             // Создаём глобальный reducer
    this.state = this.rootReducer(this.state);  // Получаем ГС и разбиваем его на модули
  }

  // Для подписки на изменение глобального состояния реализован следующим метод:
  subscribe(key, callback) {
    this.subscribers[key] = callback;           // Создаём слушателя ГС
    this.subscribers[key](this.state);          // Высылаем ему текущие ГС
  }

  // Для отписки от изменения глобального состояния реализован следующим метод:
  unsubscribe(key) {
    delete this.subscribers[key];               // Удаляем слушателя
  }


  // Метод dispatch изменяет ГС и выполняет оповещение об изменении ГС каждого подписчика:
  dispatch(action) {
    // Изменяем ГС на основании переданного в качестве аргумента действия:
    this.state = this.rootReducer(this.state, action);

    // Функции-оповестители каждого из подписчиков перебираются:
    Object.values(this.subscribers).forEach((subscriberCallback) => {
      // Если текущее значение действительно функция, то:
      if (!!subscriberCallback && typeof subscriberCallback === "function") {
        // Выполняем функцию-оповестителя:
        subscriberCallback(this.state);
      }
    });
  }
}

// Для реализции единого источника истинности используется паттерн Singleton: при создании экземпляра
// класса будет возвращаться всегда одни и тот же объект. 

// Экспортируем экземпляр, используя паттерн Singleton, реализованный с помощью замыкания:
export const createStore = (function () {
  let storeInstance;

  return function (rootReducer) {
    if (!storeInstance) {
      storeInstance = new Store(rootReducer);
    }

    return storeInstance;
  };
})();
